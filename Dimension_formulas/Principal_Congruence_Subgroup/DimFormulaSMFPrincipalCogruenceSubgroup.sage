def dim_cusp_form_GammaN(k,j,N):
    """
    Compute the dimension of S_{k,j}(Gamma[N]) for
     N>=3 and  
    j=0 and k>=4 or j>=1 and k>=5
    """
    L = divisors(N)
    LP = [x for x in L if x.is_prime() == true]
    V = [(1-x^(-2))*(1-x^(-4)) for x in LP]
    mu = prod(V)
    """
    Notice that mu*N^10 is the index of Gamma[N] in Sp(4,Z)
    """
    A = (j+1)*(j+k-1)*(j+2*k-3)*(k-2)*N^10/1080
    B = (j+1)*(j+2*k-3)*N^8/576
    C = (j+1)*N^7/96
    d = (A-B+C)*mu
    """
    d1 = (j+1)*(8*(j+k-1)*(j+2*k-3)*(k-2)+15*(6-(j+2*k-3)*N)/N^3)*mu*N^10/8640 
    d1 = d (see the note)
    """
    return d

def dim_cusp_form_Gamma2(k,j):
    """
    Compute the dimension of S_{k,j}(Gamma[2]) for
    j=0 and k>=4 or j>=1 and k>=5
    and j even otherwise this is zero since -1 belongs to Gamma[2]
    """
    A = (k-2)*j^3
    B = 3*(k^2-3*k-3)*j^2
    C = (2*k^3-6*k^2+(15*(-1)^k-27)*k+77+75*(-1)^(k+1))*j
    D = 2*k^3+(15*(-1)^k-9)*k^2+(135*(-1)^(k+1)-17)*k+84+300*(-1)^k
    d = (A+B+C+D)/24
    return d


def dim_SV_sp4Z_even_weight_klingen_eis(k):
    """
    Compute the dimension of KE_{0,k}(Sp(4,Z)) for
    k even where KE_{0,k}(Sp(4,Z)) denotes the
    subspace of M_{0,k}(Sp(4,Z)) generated by 
    Klingen-Eisenstein series
    """
    R.<t> = PowerSeriesRing(ZZ, default_prec=k+1)
    num = t^12
    denom = (1-t^4) * (1-t^6)
    f = num / denom
    k = ZZ(k)
    d = f.list()[k]   
    return d




def smf_dims_principal(k,j,N):
    """
    later                        
    """
    L={}
    L['degree'] = 2
    L['family'] = 'S'
    L['level'] = 1
    L['weight'] = [k,0]
    L['char_orbit'] = 0
    L['total_dim'] = dtotal
    L['cusp_dim'] = dcusp
    L['eis_dim'] = dnoncusp  
    L['eis_F_dim'] = deis  
    L['eis_Q_dim'] = dklingeneis 
    L['cusp_P_dim'] = dsaitokurokawa
    L['cusp_Y_dim'] = 0
    L['cusp_G_dim'] = dgenuine
    return L 

def dim_SV_sp4Z_odd_weight_trivial_charac(k):
    """
    Compute the dimension of M_{0,k}(Sp(4,Z)) for
    k odd
    """
    R.<t> = PowerSeriesRing(ZZ, default_prec=k+1)
    num = t^35
    denom = (1-t^4) * (1-t^6) * (1-t^10) * (1-t^12)
    f = num / denom
    k = ZZ(k)
    d = f.list()[k]
    return d

def dim_splitting_SV_odd_weight(k):
    """
    idem as dim_splitting_SV_even_weight(k) but for k odd
    """
    k=ZZ(k)
    dtotal = dim_SV_sp4Z_odd_weight_trivial_charac(k)
    deis = 0
    dklingeneis = 0
    dsaitokurokawa = 0
    dgenuine = dtotal
    dcusp = dgenuine
    dnoncusp = deis + dklingeneis
    L={}
    L['degree'] = 2
    L['family'] = 'S'
    L['level'] = 1
    L['weight'] = [k,0]
    L['char_orbit'] = 0
    L['total_dim'] = dtotal
    L['cusp_dim'] = dcusp
    L['eis_dim'] = dnoncusp 
    L['eis_F_dim'] = deis  
    L['eis_Q_dim'] = dklingeneis 
    L['cusp_P_dim'] = dsaitokurokawa
    L['cusp_Y_dim'] = 0
    L['cusp_G_dim'] = dgenuine
    return L 



def dim_splitting_SV_All_weight(k):
    """
    Put everything together
    """
    k = ZZ(k)
    if k == 0 :
        return {'degree': 2, 'family': 'S', 'level': 1, 'weight': [0, 0], 'char_orbit' : 0, 'total_dim': 1, 'cusp_dim': 0, 'eis_dim': 1, 'eis_F_dim': 1,
 'eis_Q_dim': 0,
 'cusp_P_dim': 0, 'cusp_Y_dim': 0 , 'cusp_G_dim': 0}

    if k == 2 :
         return {'degree': 2, 'family': 'S', 'level': 1, 'weight': [2, 0], 'char_orbit' : 0, 'total_dim': 0, 'cusp_dim': 0, 'eis_dim': 0, 'eis_F_dim': 0,
 'eis_Q_dim': 0,
 'cusp_P_dim': 0, 'cusp_Y_dim': 0 , 'cusp_G_dim': 0}

    if (k % 2) == 1:
        return dim_splitting_SV_odd_weight(k)

    if (k % 2) == 0 and  k > 2:
        return dim_splitting_SV_even_weight(k) 


        
  